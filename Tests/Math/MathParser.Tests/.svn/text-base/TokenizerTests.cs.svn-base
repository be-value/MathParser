// --------------------------------------------------------------------------------------------------------------------
// <copyright file="TokenizerTests.cs" company="Decerno">
//   (c) 2011, Jelle de Vries
// </copyright>
// --------------------------------------------------------------------------------------------------------------------
namespace MathParser.Tests
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using Rhino.Mocks;
    using Xunit;

    /// <summary>
    /// Test cases for the Tokenizer class and its corresponsing extension method(s)
    /// </summary>
    public class TokenizerTests
    {
        /// <summary>
        /// The tokenizer used by all the tests
        /// </summary>
        private readonly Tokenizer tokenizer;

        /// <summary>
        /// Initializes a new instance of the <see cref="TokenizerTests"/> class.
        /// </summary>
        public TokenizerTests()
        {
            this.tokenizer = new Tokenizer();
        }

        #region null and empty expressions
        /// <summary>
        /// Test if calling the tokenizer with null results in an <see cref="ArgumentException"/> 
        /// being thrown.
        /// </summary>
        [Fact]
        public void TokenizeCalledWithNullThrowsArgumentException()
        {
            // Act and Assert
            Assert.Throws<ArgumentException>(() => this.tokenizer.Tokenize(null).ToList());
        }
        #endregion

        #region various scenarios
        /// <summary>
        /// Test if unknown tokens are recognized at all
        /// </summary>
        [Fact]
        public void TokenizeUnknownTokerRetunsUnknowToken()
        {
            // Arrange
            const string Expression = " @ADX# ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            Assert.Equal("@", list[0].Lexeme);
            Assert.IsType<UnknownToken>(list[0]);
            Assert.Equal("#", list[2].Lexeme);
            Assert.IsType<UnknownToken>(list[2]);
        }

        /// <summary>
        /// Test if in the process of tokenizing, the whitespace tokens are removed
        /// </summary>
        [Fact]
        public void TokenizeExpressionRemovesWhitespaceTokens()
        {
            // Arrange
            //                         0123456
            const string Expression = " ( a + 3 ) ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            Assert.Equal(5, list.Count);
        }
        #endregion

        #region Operand group

        /// <summary>
        /// Test if tokenizing an integer value returns an operand token
        /// </summary>
        [Fact]
        public void TokenizeNumberReturnsOperandToken()
        {
            // Arrange
            const string Expression = " 12 + 3 ";

            // Act
            var list = GetTokens(Expression);

            // Arrange
            Assert.IsAssignableFrom<IOperandToken>(list[0]);
        }

        /// <summary>
        /// Test if tokenizing a decimal point value returns an operan token
        /// </summary>
        [Fact]
        public void TokenizeNumberWithFixedDecimalPointReturnsOperandToken()
        {
            // Arrange
            const string Expression = " 12.3 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            Assert.Equal(1, list.Count);
            Assert.IsAssignableFrom<IOperandToken>(list[0]);
        }

        /// <summary>
        /// Test if tokenizing identifiers returns operand tokens
        /// </summary>
        [Fact]
        public void TokenizeIdentifierReturnsOperandToken()
        {
            // Arrange
            const string Expression = " v _x a12";
            
            // Act
            var list = GetTokens(Expression);

            // Arrange
            Assert.IsAssignableFrom<IOperandToken>(list[0]);
            Assert.IsAssignableFrom<IOperandToken>(list[1]);
            Assert.IsAssignableFrom<IOperandToken>(list[2]);
        }

        #endregion

        #region Operator group

        /// <summary>
        /// Test if tokenizing a plus character returns an operator token
        /// </summary>
        [Fact]
        public void TokenizePlusReturnsOperatorToken()
        {
            // Arrange
            const string Expression = " +12 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            Assert.IsAssignableFrom<IOperatorToken>(list[0]);
        }

        /// <summary>
        /// Test if tokenizing a minus character returns an operator token
        /// </summary>
        [Fact]
        public void TokenizeMinusReturnsOperatorToken()
        {
            // Arrange
            const string Expression = " -13 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            Assert.IsAssignableFrom<IOperatorToken>(list[0]);
        }

        /// <summary>
        /// Test if tokenizing a asterisk character returns an operator token
        /// </summary>
        [Fact]
        public void TokenizeAsteriskReturnsOperatorToken()
        {
            // Arrange
            const string Expression = " *14 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            Assert.IsAssignableFrom<IOperatorToken>(list[0]);
        }

        /// <summary>
        /// Test if tokenizing a slash character returns an operator token
        /// </summary>
        [Fact]
        public void TokenizeSlashReturnsOperatorToken()
        {
            // Arrange
            const string Expression = " /15 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            Assert.IsAssignableFrom<IOperatorToken>(list[0]);
        }

        /// <summary>
        /// Test if tokenizing a function identifier returns an operator token
        /// </summary>
        [Fact]
        public void TokenizeFunctionReturnsOperatorToken()
        {
            // Arrange mocking the function environment
            var mocks = new MockRepository();
            var loader = mocks.Stub<IFunctionLoader>();
            Functions.Repository = new FunctionRepository(loader);
            SetupResult.For(loader.GetFunctionInfo()).Return(new List<FunctionInfo> { new FunctionInfo { ArgumentCount = 1, Name = "sin" } });
            mocks.ReplayAll();

            // Actual function expression
            const string Expression = " sin(90) ";
            
            // Act
            var list = GetTokens(Expression);

            // Assert
            Assert.IsAssignableFrom<IOperatorToken>(list[0]);
            mocks.VerifyAll();
        }
        #endregion

        #region Meta group

        /// <summary>
        /// Test if tokenizing a left parenthesis character returns an meta token
        /// </summary>
        [Fact]
        public void TokenizeLeftParenthesisReturnsMetaToken()
        {
            // Arrange
            const string Expression = " (16 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            Assert.IsAssignableFrom<IMetaToken>(list[0]);
        }

        /// <summary>
        /// Test if tokenizing a right parenthesis character returns an meta token
        /// </summary>
        [Fact]
        public void TokenizeRightParenthesisReturnsMetaToken()
        {
            // Arrange
            const string Expression = " )17 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            Assert.IsAssignableFrom<IMetaToken>(list[0]);
        }

        /// <summary>
        /// Test if tokenizing a comma character returns an meta token
        /// </summary>
        [Fact]
        public void TokenizeCommaReturnsMetaToken()
        {
            // Arrange
            const string Expression = " ,18 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            Assert.IsAssignableFrom<IMetaToken>(list[0]);
        }

        #endregion

        #region specific tokens
        /// <summary>
        /// Test if tokenizing a number returs this specific operand token
        /// </summary>
        [Fact]
        public void TokenizeNumericReturnsNumberOperandToken()
        {
            // Arrange
            const string Expression = " 12345 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            var operandToken = list[0] as IOperandToken;
            AssertTypeOfOperand(Operand.Numeric, operandToken);
        }

        /// <summary>
        /// Test if tokenizing a decimal number returs this specific operand token
        /// </summary>
        [Fact]
        public void TokenizeNumericWithDecimalReturnsNumberOperandToken()
        {
            // Arrange
            const string Expression = " 123.45 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            Assert.Equal(1, list.Count);
            var operandToken = list[0] as IOperandToken;
            AssertTypeOfOperand(Operand.Numeric, operandToken);
        }

        /// <summary>
        /// Test is tokenizing an identifier returns this specific operand token
        /// </summary>
        [Fact]
        public void TokenizeIdentifierReturnsVariableOperandToken()
        {
            // Arrange
            const string Expresson = " _variable_ ";

            // Act
            var list = GetTokens(Expresson);

            // Assert
            var operandToken = list[0] as IOperandToken;
            AssertTypeOfOperand(Operand.Variable, operandToken);
        }

        /// <summary>
        /// Test if tokenizing a left parenthesis returns this specific metatoken
        /// </summary>
        [Fact]
        public void TokenizeLeftParenthesisReturnsLeftParenthesisToken()
        {
            // Arrange
            const string Expression = " (19 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            var metaToken = list[0] as IMetaToken;
            AssertTypeOfMeta(Meta.LeftParenthesis, metaToken);
        }

        /// <summary>
        /// Test if tokenizing a right parenthesis returns this specific metatoken
        /// </summary>
        [Fact]
        public void TokenizeRightParenthesisReturnsRightParenthesisToken()
        {
            // Arrange
            const string Expression = " )+20 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            var metaToken = list[0] as IMetaToken;
            AssertTypeOfMeta(Meta.RightParenthesis, metaToken);
        }

        /// <summary>
        /// Test if tokenizing a comma returns this specific metatoken
        /// </summary>
        [Fact]
        public void TokenizeCommaReturnsCommaToken()
        {
            // Arrange
            const string Expression = " ,21 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            var metaToken = list[0] as IMetaToken;
            AssertTypeOfMeta(Meta.Comma, metaToken);
        }

        /// <summary>
        /// Test if tokenizing a asterisk character returns an multiplication operator token
        /// </summary>
        [Fact]
        public void TokenizeAsteriskReturnsMultiplicationOperatorToken()
        {
            // Arrange
            const string Expression = " *22 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            var operatorToken = list[0] as IOperatorToken;
            AssertTypeOfOperator(Operator.Multiplication, operatorToken);
        }

        /// <summary>
        /// Test if tokenizing a slash character returns an division operator token
        /// </summary>
        [Fact]
        public void TokenizeSlashReturnsDivisionOperatorToken()
        {
            // Arrange
            const string Expression = " /23 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            var operatorToken = list[0] as IOperatorToken;
            AssertTypeOfOperator(Operator.Division, operatorToken);
        }

        /// <summary>
        /// Test if tokenizing a plus character returns addition token
        /// </summary>
        [Fact]
        public void TokenizePlusAfterNumberReturnsAdditionOperatorToken()
        {
            // Arrange
            const string Expression = " 24+ ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            var operatorToken = list[1] as IOperatorToken;
            AssertTypeOfOperator(Operator.Addition, operatorToken);
        }

        /// <summary>
        /// Test if tokenizing a plus character returns addition token
        /// </summary>
        [Fact]
        public void TokenizePlusAfterRightParenthesisReturnsAdditionOperatorToken()
        {
            // Arrange
            const string Expression = " )+ ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            var operatorToken = list[1] as IOperatorToken;
            AssertTypeOfOperator(Operator.Addition, operatorToken);
        }

        /// <summary>
        /// Test if tokenizing a minus character returns subtraction token
        /// </summary>
        [Fact]
        public void TokenizeMinusAfterNumberReturnsSubtractionOperatorToken()
        {
            // Arrange
            const string Expression = " 25- ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            var operatorToken = list[1] as IOperatorToken;
            AssertTypeOfOperator(Operator.Subtraction, operatorToken);
        }

        /// <summary>
        /// Test if tokenizing a minus character returns subtraction token
        /// </summary>
        [Fact]
        public void TokenizeMinusAfterRightParenthesisReturnsSubtractionOperatorToken()
        {
            // Arrange
            const string Expression = " )- ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            var operatorToken = list[1] as IOperatorToken;
            AssertTypeOfOperator(Operator.Subtraction, operatorToken);
        }

        /// <summary>
        /// Test if tokenizing a plus character returns unary plus token
        /// </summary>
        [Fact]
        public void TokenizePlusAsFirstTokenReturnsUnaryPlusOperatorToken()
        {
            // Arrange
            const string Expression = " +26 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            var operatorToken = list[0] as IOperatorToken;
            AssertTypeOfOperator(Operator.UnaryPlus, operatorToken);
        }

        /// <summary>
        /// Test if tokenizing a plus character returns unary plus token
        /// </summary>
        [Fact]
        public void TokenizePlusAfterLeftParenthesisReturnsUnaryPlusOperatorToken()
        {
            // Arrange
            const string Expression = " (+26 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            var operatorToken = list[1] as IOperatorToken;
            AssertTypeOfOperator(Operator.UnaryPlus, operatorToken);
        }

        /// <summary>
        /// Test if tokenizing a plus character returns unary plus token
        /// </summary>
        [Fact]
        public void TokenizePlusAfterCommaReturnsUnaryPlusOperatorToken()
        {
            // Arrange
            const string Expression = " ,+26 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            var operatorToken = list[1] as IOperatorToken;
            AssertTypeOfOperator(Operator.UnaryPlus, operatorToken);
        }

        /// <summary>
        /// Test if tokenizing a plus character returns unary plus token
        /// </summary>
        [Fact]
        public void TokenizePlusAfterOperatorReturnsUnaryPlusOperatorToken()
        {
            // Arrange
            const string Expression = " *+26 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            var operatorToken = list[1] as IOperatorToken;
            AssertTypeOfOperator(Operator.UnaryPlus, operatorToken);
        }

        /// <summary>
        /// Test if tokenizing a minus character returns unary minus token
        /// </summary>
        [Fact]
        public void TokenizeMinusAsFirstTokenReturnsUnaryMinusOperatorToken()
        {
            // Arrange
            const string Expression = " -26 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            var operatorToken = list[0] as IOperatorToken;
            AssertTypeOfOperator(Operator.UnaryMinus, operatorToken);
        }

        /// <summary>
        /// Test if tokenizing a minus character returns unary minus token
        /// </summary>
        [Fact]
        public void TokenizeMinusAfterLeftParenthesisReturnsUnaryMinusOperatorToken()
        {
            // Arrange
            const string Expression = " (-26 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            var operatorToken = list[1] as IOperatorToken;
            AssertTypeOfOperator(Operator.UnaryMinus, operatorToken);
        }

        /// <summary>
        /// Test if tokenizing a minus character returns unary minus token
        /// </summary>
        [Fact]
        public void TokenizeMinusAfterCommaReturnsUnaryMinusOperatorToken()
        {
            // Arrange
            const string Expression = " ,-26 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            var operatorToken = list[1] as IOperatorToken;
            AssertTypeOfOperator(Operator.UnaryMinus, operatorToken);
        }

        /// <summary>
        /// Test if tokenizing a minus character returns unary minus token
        /// </summary>
        [Fact]
        public void TokenizeMinusAfterOperatorReturnsUnaryMinusOperatorToken()
        {
            // Arrange
            const string Expression = " *-26 ";

            // Act
            var list = GetTokens(Expression);

            // Assert
            var operatorToken = list[1] as IOperatorToken;
            AssertTypeOfOperator(Operator.UnaryMinus, operatorToken);
        }
        #endregion

        #region helper methods
        /// <summary>
        /// Asserts if the type of the token is as expected
        /// </summary>
        /// <param name="expectedType">The expected operand type</param>
        /// <param name="operandToken">The operand token containing the actual type value</param>
        private static void AssertTypeOfOperand(Operand expectedType, IOperandToken operandToken)
        {
            if (null == operandToken)
            {
                throw new Exception("no operand token was provided");
            }

            Assert.Equal(expectedType, operandToken.Type);
        }

        /// <summary>
        /// Asserts if the type of the token is as expected
        /// </summary>
        /// <param name="expectedType">The expected meta type</param>
        /// <param name="metaToken">The meta token containing the actual type value</param>
        private static void AssertTypeOfMeta(Meta expectedType, IMetaToken metaToken)
        {
            if (null == metaToken)
            {
                throw new Exception("no meta token was provided");
            }

            Assert.Equal(expectedType, metaToken.Type);
        }

        /// <summary>
        /// Asserts if the type of the token is as expected
        /// </summary>
        /// <param name="expectedType">The expected operator type</param>
        /// <param name="operatorToken">The operator token containing the actual type value</param>
        private static void AssertTypeOfOperator(Operator expectedType, IOperatorToken operatorToken)
        {
            if (null == operatorToken)
            {
                throw new Exception("no operator token was provided");
            }

            Assert.Equal(expectedType, operatorToken.Type);
        }

        /// <summary>
        /// Action for many test to trigger the tokenizer
        /// </summary>
        /// <param name="expression">expression to tokenize</param>
        /// <returns>The resulting list of tokens</returns>
        private static IList<IToken> GetTokens(string expression)
        {
            return expression.Tokenize().ToList();
        }
        #endregion
    }
}
